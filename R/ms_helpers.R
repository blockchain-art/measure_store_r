#' Generates a random unique key. Intended usage is for the creation of temporary bitmaps
#' @export
#' @return "redis:bitops:dbhhg8i2hga7ee7g6bh5hjhdd5217bjh075jh94c"
unique_key <- function() {
  key <- tolower(paste("redis:bitops:", paste(sample(c(0:9, LETTERS[1:10]), 40, T), collapse = ''), sep=""))

  return(key)
}

#' Writes given indexes to RedisRoaring under a uniquely generated key
#' @export
#' @param indexes character variable e.g.: \code{c("1, 3, 4", "2")}
#' @param roaring_client RedisRoaring client e.g.: \cr
#' \code{confl <- redis_config(url='redis://127.0.0.1:6380/1')} \cr
#' \code{roaring_client <- redux::hiredis(confl)}
#' @return "redis:bitops:8dd1b989996gg8523633c06h7d4026067fc1cfc6" "redis:bitops:06d01cfc2gijj2da3hjdc36271ga6g15bcbc0773"
write_indexes_to_redis <- function(indexes, roaring_client) {
  storage_keys <- c()

  for (i in indexes) {
    key <- i
    dest_key <- unique_key()

    roaring_client$command(c("R.APPENDINTARRAY", dest_key, as.numeric(strsplit(key,split=", ",fixed=TRUE)[[1]])))
    storage_keys <- append(storage_keys, dest_key)
  }

  return(storage_keys)
}

#' Transforms bitmaps to respondent level data
#' @export
#' @param bitmaps a Ruby array of hashes
#' @param roaring_client RedisRoaring client e.g.: \cr
#' \code{confl <- redis_config(url='redis://127.0.0.1:6380/1')} \cr
#' \code{roaring_client <- redux::hiredis(confl)}
#' @return \tabular{rrrrr}{
#'  brand \tab usage             \tab                                       root_key  \tab respondent_id\cr
#' 1  \tab Pepsi \tab    1 response_id|ms8b129767|cds1c52f958|s9644a47e|cdsd0eb5e70|i1 \tab            2\cr
#' 2  \tab Fanta \tab    1 response_id|ms8b129767|cds1c52f958|sa1a4c184|cdsd0eb5e70|i1 \tab           3\cr
#' 2.1 \tab Fanta \tab    1 response_id|ms8b129767|cds1c52f958|sa1a4c184|cdsd0eb5e70|i1 \tab            4\cr
#' 3   \tab Coke  \tab   1 response_id|ms8b129767|cds1c52f958|s50bf8369|cdsd0eb5e70|i1   \tab          1\cr
#' 3.1 \tab Coke  \tab   1 response_id|ms8b129767|cds1c52f958|s50bf8369|cdsd0eb5e70|i1  \tab           2\cr
#' }
to_respondent_level_data <- function(bitmaps, roaring_client) {
  bitmaps_df <- as.data.frame(bind_rows(bitmaps))
  duptimes <- c()
  respondents <- c()

  for (column_number in 1:nrow(bitmaps_df)) {
    key <- bitmaps_df[column_number, "root_key"]
    indexes <- roaring_client$command(c("R.GETINTARRAY", key))

    duptimes <- append(duptimes, length(indexes))
    respondents <- append(respondents, as.integer(indexes))
  }

  idx <- rep(1:nrow(bitmaps_df), duptimes)

  dupdf <- bitmaps_df[idx,]
  dupdf$respondent_id <- respondents

  return(dupdf)
}

#' Generates member counts
#' @export
#' @param respondent_level_bitmaps can be generated by calling the following function: \code{to_respondent_level_data(bitmaps, roaring)}
#' @param roaring_client RedisRoaring client e.g.: \cr
#' \code{confl <- redis_config(url='redis://127.0.0.1:6380/1')} \cr
#' \code{roaring_client <- redux::hiredis(confl)}
#' @return \tabular{rrrrr}{
#' member_count \tab root_key\cr
#' <int> \tab <chr>\cr
#'   1   \tab          1 redis:bitops:3gfbiagag29bdeh199hab4482adgcbd94h97847f\cr
#'   2   \tab       2 redis:bitops:0hb9f0ciii1cbcb7che274b36792a82h5gef1agf\cr
#' }
member_count <- function(respondent_level_bitmaps, roaring_client) {
  member_counts <- respondent_level_bitmaps %>%
    group_by(respondent_id) %>%
    summarise(member_count = n()) %>%
    group_by(member_count) %>%
    summarize(indexes = paste(sort(unique(respondent_id)),collapse=", ")) %>%
    mutate(root_key = write_indexes_to_redis(indexes, roaring_client)) %>%
    select(-indexes)

  return(member_counts)
}



